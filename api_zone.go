
/*
 * STACKIT DNS API
 *
 * This api provides dns
 *
 * API version: 1.0
 * Contact: dns@stackit.cloud
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ZoneApiService service
/*
ZoneApiService All get selected zones
All zone
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId project id
 * @param optional nil or *ZoneApiV1ProjectsProjectIdZonesGetOpts - Optional Parameters:
     * @param "Page" (optional.Int32) -  page
     * @param "PageSize" (optional.Int32) -  page size
     * @param "DnsNameEq" (optional.String) -  filter dns name equal
     * @param "DnsNameLike" (optional.String) -  filter dns name like
     * @param "TypeEq" (optional.String) -  filter type
     * @param "PrimaryNameServerEq" (optional.String) -  filter primary name server equal
     * @param "PrimaryNameServerLike" (optional.String) -  filter primary name server like
     * @param "IsReverseZoneEq" (optional.Bool) -  filter reverse zone equal
     * @param "ActiveEq" (optional.Bool) -  filter active equal
     * @param "CreationStartedGt" (optional.String) -  filter creation started greater with utc timestamp
     * @param "CreationStartedLt" (optional.String) -  filter creation started lesser with utc timestamp
     * @param "CreationStartedGte" (optional.String) -  filter creation started greater equal with utc timestamp
     * @param "CreationStartedLte" (optional.String) -  filter creation started lesser equal with utc timestamp
     * @param "CreationFinishedGt" (optional.String) -  filter creation finished greater with utc timestamp
     * @param "CreationFinishedLt" (optional.String) -  filter creation finished lesser with utc timestamp
     * @param "CreationFinishedGte" (optional.String) -  filter creation finished greater equal with utc timestamp
     * @param "CreationFinishedLte" (optional.String) -  filter creation finished lesser equal with utc timestamp
     * @param "UpdateStartedGt" (optional.String) -  filter update started greater with utc timestamp
     * @param "UpdateStartedLt" (optional.String) -  filter update started lesser with utc timestamp
     * @param "UpdateStartedGte" (optional.String) -  filter update started greater equal with utc timestamp
     * @param "UpdateStartedLte" (optional.String) -  filter update started lesser equal with utc timestamp
     * @param "UpdateFinishedGt" (optional.String) -  filter update finished greater with utc timestamp
     * @param "UpdateFinishedLt" (optional.String) -  filter update finished lesser with utc timestamp
     * @param "UpdateFinishedGte" (optional.String) -  filter update finished greater equal with utc timestamp
     * @param "UpdateFinishedLte" (optional.String) -  filter update finished lesser equal with utc timestamp
     * @param "OrderByDnsName" (optional.String) -  order by dns name
     * @param "OrderByCreationStarted" (optional.String) -  order by creationStarted
     * @param "OrderByCreationFinished" (optional.String) -  order by creationFinished
     * @param "OrderByUpdateStarted" (optional.String) -  order by updateStarted
     * @param "OrderByUpdateFinished" (optional.String) -  order by updateFinished
@return ZoneResponseZoneAll
*/

type ZoneApiV1ProjectsProjectIdZonesGetOpts struct {
    Page optional.Int32
    PageSize optional.Int32
    DnsNameEq optional.String
    DnsNameLike optional.String
    TypeEq optional.String
    PrimaryNameServerEq optional.String
    PrimaryNameServerLike optional.String
    IsReverseZoneEq optional.Bool
    ActiveEq optional.Bool
    CreationStartedGt optional.String
    CreationStartedLt optional.String
    CreationStartedGte optional.String
    CreationStartedLte optional.String
    CreationFinishedGt optional.String
    CreationFinishedLt optional.String
    CreationFinishedGte optional.String
    CreationFinishedLte optional.String
    UpdateStartedGt optional.String
    UpdateStartedLt optional.String
    UpdateStartedGte optional.String
    UpdateStartedLte optional.String
    UpdateFinishedGt optional.String
    UpdateFinishedLt optional.String
    UpdateFinishedGte optional.String
    UpdateFinishedLte optional.String
    OrderByDnsName optional.String
    OrderByCreationStarted optional.String
    OrderByCreationFinished optional.String
    OrderByUpdateStarted optional.String
    OrderByUpdateFinished optional.String
}

func (a *ZoneApiService) V1ProjectsProjectIdZonesGet(ctx context.Context, projectId string, localVarOptionals *ZoneApiV1ProjectsProjectIdZonesGetOpts) (ZoneResponseZoneAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ZoneResponseZoneAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("pageSize", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DnsNameEq.IsSet() {
		localVarQueryParams.Add("dnsName[eq]", parameterToString(localVarOptionals.DnsNameEq.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DnsNameLike.IsSet() {
		localVarQueryParams.Add("dnsName[like]", parameterToString(localVarOptionals.DnsNameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeEq.IsSet() {
		localVarQueryParams.Add("type[eq]", parameterToString(localVarOptionals.TypeEq.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrimaryNameServerEq.IsSet() {
		localVarQueryParams.Add("primaryNameServer[eq]", parameterToString(localVarOptionals.PrimaryNameServerEq.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrimaryNameServerLike.IsSet() {
		localVarQueryParams.Add("primaryNameServer[like]", parameterToString(localVarOptionals.PrimaryNameServerLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsReverseZoneEq.IsSet() {
		localVarQueryParams.Add("isReverseZone[eq]", parameterToString(localVarOptionals.IsReverseZoneEq.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActiveEq.IsSet() {
		localVarQueryParams.Add("active[eq]", parameterToString(localVarOptionals.ActiveEq.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationStartedGt.IsSet() {
		localVarQueryParams.Add("creationStarted[gt]", parameterToString(localVarOptionals.CreationStartedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationStartedLt.IsSet() {
		localVarQueryParams.Add("creationStarted[lt]", parameterToString(localVarOptionals.CreationStartedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationStartedGte.IsSet() {
		localVarQueryParams.Add("creationStarted[gte]", parameterToString(localVarOptionals.CreationStartedGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationStartedLte.IsSet() {
		localVarQueryParams.Add("creationStarted[lte]", parameterToString(localVarOptionals.CreationStartedLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationFinishedGt.IsSet() {
		localVarQueryParams.Add("creationFinished[gt]", parameterToString(localVarOptionals.CreationFinishedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationFinishedLt.IsSet() {
		localVarQueryParams.Add("creationFinished[lt]", parameterToString(localVarOptionals.CreationFinishedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationFinishedGte.IsSet() {
		localVarQueryParams.Add("creationFinished[gte]", parameterToString(localVarOptionals.CreationFinishedGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreationFinishedLte.IsSet() {
		localVarQueryParams.Add("creationFinished[lte]", parameterToString(localVarOptionals.CreationFinishedLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateStartedGt.IsSet() {
		localVarQueryParams.Add("updateStarted[gt]", parameterToString(localVarOptionals.UpdateStartedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateStartedLt.IsSet() {
		localVarQueryParams.Add("updateStarted[lt]", parameterToString(localVarOptionals.UpdateStartedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateStartedGte.IsSet() {
		localVarQueryParams.Add("updateStarted[gte]", parameterToString(localVarOptionals.UpdateStartedGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateStartedLte.IsSet() {
		localVarQueryParams.Add("updateStarted[lte]", parameterToString(localVarOptionals.UpdateStartedLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateFinishedGt.IsSet() {
		localVarQueryParams.Add("updateFinished[gt]", parameterToString(localVarOptionals.UpdateFinishedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateFinishedLt.IsSet() {
		localVarQueryParams.Add("updateFinished[lt]", parameterToString(localVarOptionals.UpdateFinishedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateFinishedGte.IsSet() {
		localVarQueryParams.Add("updateFinished[gte]", parameterToString(localVarOptionals.UpdateFinishedGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateFinishedLte.IsSet() {
		localVarQueryParams.Add("updateFinished[lte]", parameterToString(localVarOptionals.UpdateFinishedLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderByDnsName.IsSet() {
		localVarQueryParams.Add("orderBy[dnsName]", parameterToString(localVarOptionals.OrderByDnsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderByCreationStarted.IsSet() {
		localVarQueryParams.Add("orderBy[creationStarted]", parameterToString(localVarOptionals.OrderByCreationStarted.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderByCreationFinished.IsSet() {
		localVarQueryParams.Add("orderBy[creationFinished]", parameterToString(localVarOptionals.OrderByCreationFinished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderByUpdateStarted.IsSet() {
		localVarQueryParams.Add("orderBy[updateStarted]", parameterToString(localVarOptionals.OrderByUpdateStarted.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderByUpdateFinished.IsSet() {
		localVarQueryParams.Add("orderBy[updateFinished]", parameterToString(localVarOptionals.OrderByUpdateFinished.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ZoneResponseZoneAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ZoneApiService Post create a new zone
Post zone create a new zone
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body zone to create
 * @param projectId project id
@return ZoneResponseZone
*/
func (a *ZoneApiService) V1ProjectsProjectIdZonesPost(ctx context.Context, body ZoneZonePost, projectId string) (ZoneResponseZone, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ZoneResponseZone
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 202 {
			var v ZoneResponseZone
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ZoneApiService Delete delete a zone
Delete delete a zone
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId project id
 * @param zoneId zone id
@return SerializerMessage
*/
func (a *ZoneApiService) V1ProjectsProjectIdZonesZoneIdDelete(ctx context.Context, projectId string, zoneId string) (SerializerMessage, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SerializerMessage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 202 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ZoneApiService Get a single zone
Get zone
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId project id
 * @param zoneId zone id
@return ZoneResponseZone
*/
func (a *ZoneApiService) V1ProjectsProjectIdZonesZoneIdGet(ctx context.Context, projectId string, zoneId string) (ZoneResponseZone, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ZoneResponseZone
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ZoneResponseZone
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ZoneApiService Put update an existing zone
Put update an existing zone
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body zone to update
 * @param projectId project id
 * @param zoneId zone id
@return ZoneResponseZone
*/
func (a *ZoneApiService) V1ProjectsProjectIdZonesZoneIdPut(ctx context.Context, body DomainUpdateZone, projectId string, zoneId string) (ZoneResponseZone, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ZoneResponseZone
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones/{zoneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 202 {
			var v ZoneResponseZone
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ZoneApiService Restore  an inactive zone but will not restore the record sets
Restore  an inactive zone but will not restore the record sets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId project id
 * @param zoneId zone id
@return SerializerMessage
*/
func (a *ZoneApiService) V1ProjectsProjectIdZonesZoneIdRestoresPost(ctx context.Context, projectId string, zoneId string) (SerializerMessage, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SerializerMessage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/projects/{projectId}/zones/{zoneId}/restores"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", fmt.Sprintf("%v", projectId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zoneId"+"}", fmt.Sprintf("%v", zoneId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 202 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 502 {
			var v SerializerMessage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
